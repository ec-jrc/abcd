{
    "global": {
        "waveforms_buffer_max_size": 4096,
        "waveforms_buffer_max_size_note1": "This value is in number of waveforms in the buffer",
        "waveforms_buffer_max_size_note2": "It is not a strict threshold, if more are available in the readout they are not discarded.",
        "waveforms_buffer_max_size_note3": "If too big, the following analysis steps might slow down",
        "waveforms_buffer_max_size_note4": "If too small, then the overhead might be too much",
        "waveforms_buffer_max_size_note5": "Waveform minimum dimension: 14 B (header) + 2 B * samples_number",
        "zzz": null
    },
    "cards": [
        {
            "id": 0,
            "model": "ADQ14DC-4A-VG",
            "model_note": "This model has the FWPD generation 1",
            "serial": "SPD-07721",
            "enable": true,
            "clock_source": "internal",
            "clock_source_possible_value0": "internal",
            "clock_source_possible_value1": "external_10MHz",
            "clock_source_possible_value2": "external",
            "clock_source_possible_value3": "external_PXIsync",
            "clock_source_possible_value4": "external_PXIe_100MHz",
            "timestamp_bit_shift": 5,
            "timestamp_bit_shift_note1": "the timestamp may be shifted in order to align it with the waan analysis module",
            "timestamp_bit_shift_note2": "to have 8 bits of fractional part use:",
            "timestamp_bit_shift_note3": "ADQ14-4A: 4 bit",
            "timestamp_bit_shift_note4": "ADQ14-4C: 5 bit",
            "timestamp_bit_shift_note5": "The timestamps with these settings are not compatible between the two variants",
	    "moving_average_bypass": false,
	    "moving_average_bypass_note": "this disables the smoothing module after the DBS",
            "trigger": {
                "source": "channels",
                "source_possible_value1": "software",
                "source_possible_value2": "external",
                "source_possible_value3": "channels",
                "impedance": "50_Ohm",
                "impedance_note": "input impedance of the 'trig' port",
                "impedance_possible_value1": "50_Ohm",
                "impedance_possible_value2": "high",
                "zzz": null
            },
            "sync": {
                "impedance": "high",
                "impedance_note": "input impedance of the 'sync' port",
                "impedance_possible_value1": "50_Ohm",
                "impedance_possible_value2": "high",
                "impedance_WARNING": "when using 50_Ohm, the board does not seem to trigger",
                "zzz": null
            },
            "transfer": {
                "buffer_size": 1024,
                "buffer_size_note1": "in kiB units",
                "buffer_size_note2": "minimum value: 1",
                "buffer_size_note3": "if too big, the buffers will take forever to fill",
                "buffers_number": 16,
                "buffers_number_note": "suggested minimum value is 8",
                "timeout": 60000,
                "timeout_note1": "in ms units",
                "timeout_note2": "documentation suggests to use a big number such as 60000",
                "data_reading_timeout": 3000,
                "data_reading_timeout_note1": "in ms units",
                "data_reading_timeout_note2": "used by ABCD to stop the fastest inner loop that reads data",
                "data_reading_timeout_note3": "when the rate is too high the inner loop was blocking the program",
                "event_counters_base_address": "0x50130000",
                "event_counters_base_address_possible_value": "this should be either an hex-formatted string starting with '0x' or an integer number",
                "event_counters_base_address_note1": "This is the register address to access the counter of the trigger events",
                "event_counters_base_address_note2": "There is the (undocumented) function PDGetEventCounters() in the ADQAPI.h that gives similar information, but only relative to channel A",
                "event_counters_base_address_note3": "The actual address might change with different firmware versions.",
                "event_counters_base_address_note4": "To find out the real address, find in the log files, produced by the API, the address of the first LevelTrigPD.",
                "zzz": null
            },
            "channels": [
                {
                    "id": 0,
                    "enable": true,
                    "input_range": 1000,
                    "input_range_note": "in mV units, it is adapted by the firwmware to the closest possible value",
                    "DC_offset": 0,
                    "DC_offset_note": "in ADC channels, this will set also the DBS target to the same value",
                    "DBS_disable": false,
                    "trigger_level": -200,
                    "trigger_level_note": "relative to the baseline of the signal, in ADC channels",
                    "trigger_hysteresis": 30,
                    "trigger_hysteresis_note": "in ADC channels",
                    "trigger_slope": "falling",
                    "trigger_slope_possible_value1": "rising",
                    "trigger_slope_possible_value2": "falling",
                    "pretrigger": 128,
                    "pretrigger_note1": "for the 4A variant this probably needs to be a multiple of 2",
                    "pretrigger_note2": "for the 4C variant this probably needs to be a multiple of 4",
                    "pretrigger_note3": "TODO: verify this statement",
                    "smooth_samples": 32,
                    "smooth_samples_note1": "this must be between 0 and 100",
                    "smooth_samples_note2": "it is expressed in clock samples, in steps of 4 ns",
                    "smooth_samples_note3": "for the -4A variant this means a multiple of 2",
                    "smooth_samples_note4": "for the -4C variant this means a multiple of 4",
                    "smooth_samples_note5": "WARNING: This setting might cause a non-intuitive behaviour, because it moves the baseline",
                    "smooth_delay": 32,
                    "smooth_delay_note1": "this is the delay between the threshold crossing determination and the smoothed samples",
                    "smooth_delay_note2": "WARNING: smooth_samples + smooth_delay <= 100",
                    "scope_samples": 1024,
                    "records_number": -1,
                    "records_number_note1": "if set to -1 it should start an infinite acquisition",
                    "records_number_note2": "otherwise the digitizer stops reading signals after that number of records",
                    "records_number_note3": "WARNING: absp will not stop its acquisition, it must be manually done",
                    "zzz": null
                },
                {
                    "id": 1,
                    "enable": false,
                    "input_range": 1000,
                    "DC_offset": 0,
                    "DBS_disable": false,
                    "trigger_level": -200,
                    "trigger_hysteresis": 30,
                    "trigger_slope": "falling",
                    "pretrigger": 128,
                    "smooth_samples": 92,
                    "smooth_delay": 8,
                    "scope_samples": 1024,
                    "records_number": -1,
                    "zzz": null
                },
                {
                    "id": 2,
                    "enable": false,
                    "input_range": 1000,
                    "DC_offset": 0,
                    "DBS_disable": false,
                    "trigger_level": -200,
                    "trigger_hysteresis": 30,
                    "trigger_slope": "falling",
                    "pretrigger": 128,
                    "smooth_samples": 92,
                    "smooth_delay": 8,
                    "scope_samples": 1024,
                    "records_number": -1,
                    "zzz": null
                },
                {
                    "id": 3,
                    "enable": false,
                    "input_range": 1000,
                    "DC_offset": 0,
                    "DBS_disable": false,
                    "trigger_level": -200,
                    "trigger_hysteresis": 30,
                    "trigger_slope": "falling",
                    "pretrigger": 128,
                    "smooth_samples": 92,
                    "smooth_delay": 8,
                    "scope_samples": 1024,
                    "records_number": -1,
                    "zzz": null
                },
                {}
            ]
        },
        {}
    ],
    "scripts": [
        {
            "enable": true,
            "state": [203, 204],
            "when": "pre",
            "when_possible_value0": "pre",
            "when_possible_value1": "post",
            "source": "print(\"LUA MESSAGE: Either start or stop of acquisition!!!\")",
            "source_note": "This can be a file name or the actual script as a string",
            "zzz": null
        },
        {
            "enable": true,
            "state": [108, 406],
            "state_note": "This will run in the configuration state",
            "when": "post",
            "source": "absp/scripts/display_digitizers.lua",
            "source_note1": "If using a file name as the script source, make sure that it is accessible by absp.",
            "source_note2": "If the script file is not accessible, this string will be treated as the script itself.",
            "zzz": null
        },
        {}
    ],
    "zzz": null
}
